<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PROJECT_NAME: SCU</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PROJECT_NAME
   &#160;<span id="projectnumber">PROJECT_NUMBER</span>
   </div>
   <div id="projectbrief">PROJECT_BRIEF</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SCU<div class="ingroups"><a class="el" href="group___x_m_clib.html">XMC Peripheral Library</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>System Control Unit(SCU) driver for XMC microcontroller family.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for SCU:</div>
<div class="dyncontent">
<div class="center"><img src="group___s_c_u.png" border="0" usemap="#group______s__c__u" alt=""/></div>
<map name="group______s__c__u" id="group______s__c__u">
<area shape="rect" href="group___x_m_clib.html" title=" " alt="" coords="5,5,160,31"/>
<area shape="rect" title="System Control Unit(SCU) driver for XMC microcontroller family." alt="" coords="208,5,257,31"/>
</map>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga258feddd9c813aeac2248fa026a91b81"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="group___s_c_u.html#ga038b306c834ed7183c64dc8f92bc5ee7">XMC_SCU_STATUS</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga258feddd9c813aeac2248fa026a91b81">XMC_SCU_STATUS_t</a></td></tr>
<tr class="separator:ga258feddd9c813aeac2248fa026a91b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b50170c441fb21833c07a27b814a581"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4b50170c441fb21833c07a27b814a581">XMC_SCU_INTERRUPT_EVENT_HANDLER_t</a>) (void)</td></tr>
<tr class="separator:ga4b50170c441fb21833c07a27b814a581"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga038b306c834ed7183c64dc8f92bc5ee7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga038b306c834ed7183c64dc8f92bc5ee7">XMC_SCU_STATUS</a> { <a class="el" href="group___s_c_u.html#gga038b306c834ed7183c64dc8f92bc5ee7a764eaaa84d169b3222ae9174d1fa6855">XMC_SCU_STATUS_OK</a> = 0UL, 
<a class="el" href="group___s_c_u.html#gga038b306c834ed7183c64dc8f92bc5ee7aaf8f778e9be5e754dcaa0c1cf83e1e4b">XMC_SCU_STATUS_ERROR</a>, 
<a class="el" href="group___s_c_u.html#gga038b306c834ed7183c64dc8f92bc5ee7a6f6a43bd2a61be2a1b0b57601d58bd77">XMC_SCU_STATUS_BUSY</a>
 }</td></tr>
<tr class="separator:ga038b306c834ed7183c64dc8f92bc5ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3b2b4eb2b1fb84d9aa0b3b2997941d10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cmsis__gcc_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga3b2b4eb2b1fb84d9aa0b3b2997941d10">XMC_SCU_SetCcuTriggerHigh</a> (const uint32_t trigger)</td></tr>
<tr class="separator:ga3b2b4eb2b1fb84d9aa0b3b2997941d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee8a9cc1bea24cd3a6027ecfa02cac9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cmsis__gcc_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaee8a9cc1bea24cd3a6027ecfa02cac9d">XMC_SCU_SetCcuTriggerLow</a> (const uint32_t trigger)</td></tr>
<tr class="separator:gaee8a9cc1bea24cd3a6027ecfa02cac9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08c337e8a728604e7eb54dff78ae2d9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga08c337e8a728604e7eb54dff78ae2d9d">XMC_SCU_CLOCK_Init</a> (const XMC_SCU_CLOCK_CONFIG_t *const config)</td></tr>
<tr class="separator:ga08c337e8a728604e7eb54dff78ae2d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4cfb9545d1e561e1f24aeaa69af821c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab4cfb9545d1e561e1f24aeaa69af821c">XMC_SCU_INTERRUPT_EnableEvent</a> (const XMC_SCU_INTERRUPT_EVENT_t event)</td></tr>
<tr class="separator:gab4cfb9545d1e561e1f24aeaa69af821c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa814678729d6b7f41c558e768ba8ecd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaa814678729d6b7f41c558e768ba8ecd4">XMC_SCU_INTERRUPT_DisableEvent</a> (const XMC_SCU_INTERRUPT_EVENT_t event)</td></tr>
<tr class="separator:gaa814678729d6b7f41c558e768ba8ecd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa55b2098ce803174e7dfd680d0c30728"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gaa55b2098ce803174e7dfd680d0c30728">XMC_SCU_INTERRUPT_TriggerEvent</a> (const XMC_SCU_INTERRUPT_EVENT_t event)</td></tr>
<tr class="separator:gaa55b2098ce803174e7dfd680d0c30728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae23dfad3e5e11c78791e5d5a777c44a8"><td class="memItemLeft" align="right" valign="top">XMC_SCU_INTERRUPT_EVENT_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gae23dfad3e5e11c78791e5d5a777c44a8">XMC_SCU_INTERUPT_GetEventStatus</a> (void)</td></tr>
<tr class="separator:gae23dfad3e5e11c78791e5d5a777c44a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd2e577339ff5af48261d18e0e41dc50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gabd2e577339ff5af48261d18e0e41dc50">XMC_SCU_INTERRUPT_ClearEventStatus</a> (const XMC_SCU_INTERRUPT_EVENT_t event)</td></tr>
<tr class="separator:gabd2e577339ff5af48261d18e0e41dc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9239de911e1602022b1e3e1121e0a126"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cmsis__gcc_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga9239de911e1602022b1e3e1121e0a126">XMC_SCU_RESET_GetDeviceResetReason</a> (void)</td></tr>
<tr class="separator:ga9239de911e1602022b1e3e1121e0a126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ab54dc1771863dfe14729caee0d3ab3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cmsis__gcc_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga6ab54dc1771863dfe14729caee0d3ab3">XMC_SCU_RESET_ClearDeviceResetReason</a> (void)</td></tr>
<tr class="separator:ga6ab54dc1771863dfe14729caee0d3ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b3caea1645eb3c2692e15e39b124b2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cmsis__gcc_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4b3caea1645eb3c2692e15e39b124b2b">XMC_SCU_CLOCK_GetCpuClockFrequency</a> (void)</td></tr>
<tr class="separator:ga4b3caea1645eb3c2692e15e39b124b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55a1be4f0e96fcda7b2c0feb542af250"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga55a1be4f0e96fcda7b2c0feb542af250">XMC_SCU_CLOCK_GetPeripheralClockFrequency</a> (void)</td></tr>
<tr class="separator:ga55a1be4f0e96fcda7b2c0feb542af250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0af70f90b9a1f24d3a0a4764543d833"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock</a> (const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)</td></tr>
<tr class="separator:gab0af70f90b9a1f24d3a0a4764543d833"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga702904d10b6e6c6a55db381763fd322f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga702904d10b6e6c6a55db381763fd322f">XMC_SCU_CLOCK_UngatePeripheralClock</a> (const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)</td></tr>
<tr class="separator:ga702904d10b6e6c6a55db381763fd322f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga804f98badedf0e0ba4ce09f445687a37"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga804f98badedf0e0ba4ce09f445687a37">XMC_SCU_CLOCK_IsPeripheralClockGated</a> (const XMC_SCU_PERIPHERAL_CLOCK_t peripheral)</td></tr>
<tr class="separator:ga804f98badedf0e0ba4ce09f445687a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac1c342fd66a4476279daaac294b62e78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cmsis__gcc_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#gac1c342fd66a4476279daaac294b62e78">XMC_SCU_GetMirrorStatus</a> (void)</td></tr>
<tr class="separator:gac1c342fd66a4476279daaac294b62e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ae03c6bcc3ccade266b46d84f7715e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group___s_c_u.html#ga258feddd9c813aeac2248fa026a91b81">XMC_SCU_STATUS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler</a> (const XMC_SCU_INTERRUPT_EVENT_t event, const <a class="el" href="group___s_c_u.html#ga4b50170c441fb21833c07a27b814a581">XMC_SCU_INTERRUPT_EVENT_HANDLER_t</a> handler)</td></tr>
<tr class="separator:ga4ae03c6bcc3ccade266b46d84f7715e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ba1ce317ce89edfea107893fbd8a0be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___s_c_u.html#ga9ba1ce317ce89edfea107893fbd8a0be">XMC_SCU_IRQHandler</a> (uint32_t sr_num)</td></tr>
<tr class="separator:ga9ba1ce317ce89edfea107893fbd8a0be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>System Control Unit(SCU) driver for XMC microcontroller family. </p>
<p>System control unit is the SoC power, reset and a clock manager with additional responsibility of providing system stability protection and other auxiliary functions.<br  />
 SCU provides the following features,</p><ol type="1">
<li>Power control</li>
<li>Reset control</li>
<li>Clock control</li>
<li>Miscellaneous control(boot mode, system interrupts etc.)<br  />
<br  />
</li>
</ol>
<p>The SCU driver is divided in to clock control logic, reset control logic, system interrupt control logic and miscellaneous control logic.<br  />
</p>
<p>Clock driver features:</p><ol type="1">
<li>Allows clock configuration using the structure XMC_SCU_CLOCK_CONFIG_t and API <a class="el" href="group___s_c_u.html#ga08c337e8a728604e7eb54dff78ae2d9d">XMC_SCU_CLOCK_Init()</a></li>
</ol>
<p>Reset driver features: <br  />
</p>
<p>Interrupt driver features:</p><ol type="1">
<li>Provides APIs for enabling/ disabling interrupt event generation <a class="el" href="group___s_c_u.html#gab4cfb9545d1e561e1f24aeaa69af821c">XMC_SCU_INTERRUPT_EnableEvent()</a>, <a class="el" href="group___s_c_u.html#gaa814678729d6b7f41c558e768ba8ecd4">XMC_SCU_INTERRUPT_DisableEvent()</a></li>
<li>Provides API for registering callback function for events <a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler()</a><br  />
</li>
</ol>
<p>Miscellaneous features:</p><ol type="1">
<li>Allows to trigger multiple capture compare unit(CCU) channels to be started together <a class="el" href="group___s_c_u.html#ga3b2b4eb2b1fb84d9aa0b3b2997941d10">XMC_SCU_SetCcuTriggerHigh()</a> </li>
</ol>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga4b50170c441fb21833c07a27b814a581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b50170c441fb21833c07a27b814a581">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EVENT_HANDLER_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* XMC_SCU_INTERRUPT_EVENT_HANDLER_t) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function pointer type used for registering callback functions on SCU event occurrence. </p>

<p class="definition">Definition at line <a class="el" href="xmc__scu_8h_source.html#l00187">187</a> of file <a class="el" href="xmc__scu_8h_source.html">xmc_scu.h</a>.</p>

</div>
</div>
<a id="ga258feddd9c813aeac2248fa026a91b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga258feddd9c813aeac2248fa026a91b81">&#9670;&nbsp;</a></span>XMC_SCU_STATUS_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="group___s_c_u.html#ga038b306c834ed7183c64dc8f92bc5ee7">XMC_SCU_STATUS</a> <a class="el" href="group___s_c_u.html#ga258feddd9c813aeac2248fa026a91b81">XMC_SCU_STATUS_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the status of SCU API execution, used to verify the SCU related API calls. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga038b306c834ed7183c64dc8f92bc5ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga038b306c834ed7183c64dc8f92bc5ee7">&#9670;&nbsp;</a></span>XMC_SCU_STATUS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group___s_c_u.html#ga038b306c834ed7183c64dc8f92bc5ee7">XMC_SCU_STATUS</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the status of SCU API execution, used to verify the SCU related API calls. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga038b306c834ed7183c64dc8f92bc5ee7a764eaaa84d169b3222ae9174d1fa6855"></a>XMC_SCU_STATUS_OK&#160;</td><td class="fielddoc"><p>SCU related operation successfully completed. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga038b306c834ed7183c64dc8f92bc5ee7aaf8f778e9be5e754dcaa0c1cf83e1e4b"></a>XMC_SCU_STATUS_ERROR&#160;</td><td class="fielddoc"><p>SCU related operation failed. When API cannot fulfill request, this value is returned. </p>
</td></tr>
<tr><td class="fieldname"><a id="gga038b306c834ed7183c64dc8f92bc5ee7a6f6a43bd2a61be2a1b0b57601d58bd77"></a>XMC_SCU_STATUS_BUSY&#160;</td><td class="fielddoc"><p>Cannot execute the SCU related operation request because another operation is in progress. <em>XMC_SCU_STATUS_BUSY</em> is returned when API is busy processing another request. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="xmc__scu_8h_source.html#l00170">170</a> of file <a class="el" href="xmc__scu_8h_source.html">xmc_scu.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="gab0af70f90b9a1f24d3a0a4764543d833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0af70f90b9a1f24d3a0a4764543d833">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_GatePeripheralClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_GatePeripheralClock </td>
          <td>(</td>
          <td class="paramtype">const XMC_SCU_PERIPHERAL_CLOCK_t&#160;</td>
          <td class="paramname"><em>peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>The peripheral for which the clock has to be gated. <b>Range:</b> Use type XMC_SCU_PERIPHERAL_CLOCK_t to identify the peripheral clock to be gated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Blocks the supply of clock to the selected peripheral.<br  />
<br  />
Clock gating helps in reducing the power consumption. User can selectively gate the clocks of unused peripherals. Note: Clock gating shall not be activated unless the module is in reset state. So use <em><a class="el" href="group___s_c_u.html#ga804f98badedf0e0ba4ce09f445687a37">XMC_SCU_CLOCK_IsPeripheralClockGated()</a></em> API before enabling the gating of any peripheral. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga804f98badedf0e0ba4ce09f445687a37">XMC_SCU_CLOCK_IsPeripheralClockGated()</a>, <a class="el" href="group___s_c_u.html#ga702904d10b6e6c6a55db381763fd322f">XMC_SCU_CLOCK_UngatePeripheralClock()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc1__scu_8c_source.html#l00612">612</a> of file <a class="el" href="xmc1__scu_8c_source.html">xmc1_scu.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="xmc1__rtc_8c_source.html#l00113">XMC_RTC_Disable()</a>, <a class="el" href="xmc__usic_8c_source.html#l00335">XMC_USIC_Disable()</a>, <a class="el" href="xmc__vadc_8c_source.html#l00171">XMC_VADC_GLOBAL_DisableModule()</a>, and <a class="el" href="xmc__wdt_8c_source.html#l00074">XMC_WDT_Disable()</a>.</p>

</div>
</div>
<a id="ga4b3caea1645eb3c2692e15e39b124b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b3caea1645eb3c2692e15e39b124b2b">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_GetCpuClockFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cmsis__gcc_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> uint32_t XMC_SCU_CLOCK_GetCpuClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Value of CPU clock frequency.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the vlaue of CPU clock frequency.<br  />
<br  />
The value is stored in a global variable <em><b>SystemCoreClock</b>.</em> It is updated when the clock configuration is done using the SCU LLD APIs. The value represents the frequency of clock used for CPU operation. <b>Range:</b> Value is of type uint32_t, and gives the value of frequency in Hertz.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga55a1be4f0e96fcda7b2c0feb542af250">XMC_SCU_CLOCK_GetPeripheralClockFrequency()</a>, <a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__scu_8h_source.html#l00425">425</a> of file <a class="el" href="xmc__scu_8h_source.html">xmc_scu.h</a>.</p>

<p class="reference">References <a class="el" href="system___x_m_c1100_8h.html#aa3cd3e43291e81e795d642b79b6088e6">SystemCoreClock</a>.</p>

</div>
</div>
<a id="ga55a1be4f0e96fcda7b2c0feb542af250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55a1be4f0e96fcda7b2c0feb542af250">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_GetPeripheralClockFrequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t XMC_SCU_CLOCK_GetPeripheralClockFrequency </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Value of peripheral clock frequency in Hertz.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the vlaue of clock frequency at which the peripherals are working.<br  />
<br  />
The value is derived from the CPU frequency. <b>Range:</b> Value is of type uint32_t. It is represented in Hertz. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga4b3caea1645eb3c2692e15e39b124b2b">XMC_SCU_CLOCK_GetCpuClockFrequency()</a>,<a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc1__scu_8c_source.html#l00776">776</a> of file <a class="el" href="xmc1__scu_8c_source.html">xmc1_scu.c</a>.</p>

<p class="reference">References <a class="el" href="_x_m_c1100_8h_source.html#l04230">SCU_CLK</a>, <a class="el" href="_x_m_c1100_8h_source.html#l02527">SCU_CLK_CLKCR_PCLKSEL_Msk</a>, <a class="el" href="_x_m_c1100_8h_source.html#l02526">SCU_CLK_CLKCR_PCLKSEL_Pos</a>, and <a class="el" href="system___x_m_c1100_8h.html#aa3cd3e43291e81e795d642b79b6088e6">SystemCoreClock</a>.</p>

<p class="reference">Referenced by <a class="el" href="xmc__i2s_8c_source.html#l00136">XMC_I2S_CH_SetBaudrate()</a>, <a class="el" href="xmc__spi_8c_source.html#l00120">XMC_SPI_CH_SetBaudrate()</a>, <a class="el" href="xmc__spi_8c_source.html#l00197">XMC_SPI_CH_SetInterwordDelay()</a>, <a class="el" href="xmc__uart_8c_source.html#l00134">XMC_UART_CH_SetBaudrate()</a>, and <a class="el" href="xmc__usic_8c_source.html#l00120">XMC_USIC_CH_SetBaudrate()</a>.</p>

</div>
</div>
<a id="ga08c337e8a728604e7eb54dff78ae2d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08c337e8a728604e7eb54dff78ae2d9d">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_Init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_Init </td>
          <td>(</td>
          <td class="paramtype">const XMC_SCU_CLOCK_CONFIG_t *const&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>Pointer to structure holding the clock prescaler values and divider values for configuring clock generators and clock tree.<br  />
 <b>Range:</b> Configure the members of structure XMC_SCU_CLOCK_CONFIG_t for various parameters of clock setup.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Initializes clock generators and clock tree.<br  />
<br  />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga55a1be4f0e96fcda7b2c0feb542af250">XMC_SCU_CLOCK_GetPeripheralClockFrequency()</a>, <a class="el" href="group___s_c_u.html#ga4b3caea1645eb3c2692e15e39b124b2b">XMC_SCU_CLOCK_GetCpuClockFrequency()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc1__scu_8c_source.html#l00529">529</a> of file <a class="el" href="xmc1__scu_8c_source.html">xmc1_scu.c</a>.</p>

<p class="reference">References <a class="el" href="xmc1__scu_8c_source.html#l00273">delay()</a>, <a class="el" href="_x_m_c1100_8h_source.html#l04232">SCU_ANALOG</a>, <a class="el" href="_x_m_c1100_8h_source.html#l04230">SCU_CLK</a>, and <a class="el" href="_x_m_c1100_8h_source.html#l04228">SCU_INTERRUPT</a>.</p>

<p class="reference">Referenced by <a class="el" href="clock__xmc1__conf_8c_source.html#l00069">SystemCoreClockSetup()</a>.</p>
<div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="group___s_c_u_ga08c337e8a728604e7eb54dff78ae2d9d_cgraph.png" border="0" usemap="#group___s_c_u_ga08c337e8a728604e7eb54dff78ae2d9d_cgraph" alt=""/></div>
<map name="group___s_c_u_ga08c337e8a728604e7eb54dff78ae2d9d_cgraph" id="group___s_c_u_ga08c337e8a728604e7eb54dff78ae2d9d_cgraph">
<area shape="rect" title=" " alt="" coords="5,5,164,32"/>
<area shape="rect" href="xmc1__scu_8c.html#af5f8c85b07d19150aaf04992923315b6" title=" " alt="" coords="212,5,265,32"/>
</map>
</div>

</div>
</div>
<a id="ga804f98badedf0e0ba4ce09f445687a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga804f98badedf0e0ba4ce09f445687a37">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_IsPeripheralClockGated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool XMC_SCU_CLOCK_IsPeripheralClockGated </td>
          <td>(</td>
          <td class="paramtype">const XMC_SCU_PERIPHERAL_CLOCK_t&#160;</td>
          <td class="paramname"><em>peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>The peripheral for which the check for clock gating has to be done. <b>Range:</b> Use type XMC_SCU_PERIPHERAL_CLOCK_t to identify the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool Status of the peripheral clock gating. <b>Range:</b> true if the peripheral clock is gated. false if the peripheral clock ungated(gate de-asserted).</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Gives the status of peripheral clock gating.<br  />
<br  />
It is recommended to use this API before enabling the gating of any peripherals through <em><a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a></em> API.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga702904d10b6e6c6a55db381763fd322f">XMC_SCU_CLOCK_UngatePeripheralClock()</a>, <a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc1__scu_8c_source.html#l00632">632</a> of file <a class="el" href="xmc1__scu_8c_source.html">xmc1_scu.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="xmc1__rtc_8c_source.html#l00155">XMC_RTC_IsEnabled()</a>.</p>

</div>
</div>
<a id="ga702904d10b6e6c6a55db381763fd322f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga702904d10b6e6c6a55db381763fd322f">&#9670;&nbsp;</a></span>XMC_SCU_CLOCK_UngatePeripheralClock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_CLOCK_UngatePeripheralClock </td>
          <td>(</td>
          <td class="paramtype">const XMC_SCU_PERIPHERAL_CLOCK_t&#160;</td>
          <td class="paramname"><em>peripheral</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">peripheral</td><td>The peripheral for which the clock has to be ungated. <b>Range:</b> Use type XMC_SCU_PERIPHERAL_CLOCK_t to identify the peripheral.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the supply of clock to the selected peripheral.<br  />
<br  />
By default when the device powers on, the peripheral clock will be gated for the peripherals that support clock gating. The peripheral clock should be enabled before using it for any functionality.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga804f98badedf0e0ba4ce09f445687a37">XMC_SCU_CLOCK_IsPeripheralClockGated()</a>, <a class="el" href="group___s_c_u.html#gab0af70f90b9a1f24d3a0a4764543d833">XMC_SCU_CLOCK_GatePeripheralClock()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc1__scu_8c_source.html#l00620">620</a> of file <a class="el" href="xmc1__scu_8c_source.html">xmc1_scu.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="xmc1__rtc_8c_source.html#l00105">XMC_RTC_Enable()</a>, <a class="el" href="xmc__usic_8c_source.html#l00296">XMC_USIC_Enable()</a>, <a class="el" href="xmc__vadc_8c_source.html#l00146">XMC_VADC_GLOBAL_EnableModule()</a>, and <a class="el" href="xmc__wdt_8c_source.html#l00059">XMC_WDT_Enable()</a>.</p>

</div>
</div>
<a id="gac1c342fd66a4476279daaac294b62e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac1c342fd66a4476279daaac294b62e78">&#9670;&nbsp;</a></span>XMC_SCU_GetMirrorStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cmsis__gcc_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> uint32_t XMC_SCU_GetMirrorStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Status of the register mirror update.<br  />
 <b>Range:</b> Use the bit mask of the SCU_GENERAL_MIRRSTS register for the mirror update event of interest. e.g.: SCU_GENERAL_MIRRSTS_RTC_CTR_Msk. Multiple update events can be combined using <em>OR</em> operation.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the status of hibernate domain register update, when the respective mirror registers are changed. <br  />
<br  />
The hibernate domain is connected to the core domain via SPI serial communication. MIRRSTS is a status register representing the communication of changed value of a mirror register to its corresponding register in the hibernate domain. The bit fields of the register indicate that a corresponding register of the hibernate domain is ready to accept a write or that the communication interface is busy with executing the previous operation.<br  />
Note: There is no hibernate domain in XMC1x devices. This register is retained for legacy purpose. </dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__scu_8h_source.html#l00543">543</a> of file <a class="el" href="xmc__scu_8h_source.html">xmc_scu.h</a>.</p>

<p class="reference">References <a class="el" href="_x_m_c1100_8h_source.html#l04227">SCU_GENERAL</a>.</p>

<p class="reference">Referenced by <a class="el" href="xmc1__rtc_8c_source.html#l00074">XMC_RTC_Init()</a>, <a class="el" href="xmc__rtc_8c_source.html#l00214">XMC_RTC_SetAlarm()</a>, <a class="el" href="xmc__rtc_8c_source.html#l00117">XMC_RTC_SetPrescaler()</a>, <a class="el" href="xmc__rtc_8c_source.html#l00132">XMC_RTC_SetTime()</a>, <a class="el" href="xmc__rtc_8c_source.html#l00093">XMC_RTC_Start()</a>, and <a class="el" href="xmc__rtc_8c_source.html#l00105">XMC_RTC_Stop()</a>.</p>

</div>
</div>
<a id="gabd2e577339ff5af48261d18e0e41dc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd2e577339ff5af48261d18e0e41dc50">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_ClearEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_INTERRUPT_ClearEventStatus </td>
          <td>(</td>
          <td class="paramtype">const XMC_SCU_INTERRUPT_EVENT_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Bit mask of the events to clear. <b>Range:</b> Use type XMC_SCU_INTERRUPT_EVENT_t for providing the input value. Multiple events can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Clears the event status bit in SRRAW register.<br  />
<br  />
The events are cleared by writing value 1 to their bit positions in the SRCLR register. The API can be used when polling method is used. After detecting the event, the event status should be cleared using software to detect the event again.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gae23dfad3e5e11c78791e5d5a777c44a8">XMC_SCU_INTERUPT_GetEventStatus()</a>, <a class="el" href="group___s_c_u.html#gaa55b2098ce803174e7dfd680d0c30728">XMC_SCU_INTERRUPT_TriggerEvent()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc1__scu_8c_source.html#l00381">381</a> of file <a class="el" href="xmc1__scu_8c_source.html">xmc1_scu.c</a>.</p>

</div>
</div>
<a id="gaa814678729d6b7f41c558e768ba8ecd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa814678729d6b7f41c558e768ba8ecd4">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_DisableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_INTERRUPT_DisableEvent </td>
          <td>(</td>
          <td class="paramtype">const XMC_SCU_INTERRUPT_EVENT_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Bit mask of the event to disable. <b>Range:</b> Use type XMC_SCU_INTERRUPT_EVENT_t for providing the input value. Multiple events can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Disables generation of interrupt on occurrence of the input event.<br  />
<br  />
The events are disabled by resetting the respective bit fields in the SRMSK register. <br  />
</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_m_s_i_s___core___n_v_i_c_functions.html#ga73b4e251f59cab4e9a5e234aac02ae57">NVIC_DisableIRQ()</a>, <a class="el" href="group___s_c_u.html#gab4cfb9545d1e561e1f24aeaa69af821c">XMC_SCU_INTERRUPT_EnableEvent()</a><br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc1__scu_8c_source.html#l00351">351</a> of file <a class="el" href="xmc1__scu_8c_source.html">xmc1_scu.c</a>.</p>

</div>
</div>
<a id="gab4cfb9545d1e561e1f24aeaa69af821c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4cfb9545d1e561e1f24aeaa69af821c">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_EnableEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_INTERRUPT_EnableEvent </td>
          <td>(</td>
          <td class="paramtype">const XMC_SCU_INTERRUPT_EVENT_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Bit mask of the event to enable. <b>Range:</b> Use type XMC_SCU_INTERRUPT_EVENT_t for providing the input value. Multiple events can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Enables the generation of interrupt for the input events.<br  />
<br  />
The events are enabled by setting the respective bit fields in the SRMSK register. <br  />
Note: User should separately enable the NVIC node responsible for handling the SCU interrupt. The interrupt will be generated when the respective event occurs. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_m_s_i_s___core___n_v_i_c_functions.html#ga57b3064413dbc7459d9646020fdd8bef">NVIC_EnableIRQ()</a>, <a class="el" href="group___s_c_u.html#gaa814678729d6b7f41c558e768ba8ecd4">XMC_SCU_INTERRUPT_DisableEvent()</a><br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc1__scu_8c_source.html#l00342">342</a> of file <a class="el" href="xmc1__scu_8c_source.html">xmc1_scu.c</a>.</p>

<p class="reference">Referenced by <a class="el" href="_generated_2_c_l_o_c_k___x_m_c1_2clock__xmc1_8c_source.html#l00093">CLOCK_XMC1_Init()</a>.</p>

</div>
</div>
<a id="ga4ae03c6bcc3ccade266b46d84f7715e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ae03c6bcc3ccade266b46d84f7715e6">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_SetEventHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group___s_c_u.html#ga258feddd9c813aeac2248fa026a91b81">XMC_SCU_STATUS_t</a> XMC_SCU_INTERRUPT_SetEventHandler </td>
          <td>(</td>
          <td class="paramtype">const XMC_SCU_INTERRUPT_EVENT_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group___s_c_u.html#ga4b50170c441fb21833c07a27b814a581">XMC_SCU_INTERRUPT_EVENT_HANDLER_t</a>&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>The event for which the interrupt handler is to be configured. <br  />
 <b>Range:</b> Use type XMC_SCU_INTERRUPT_EVENT_t for identifying the event. </td></tr>
    <tr><td class="paramname">handler</td><td>Name of the function to be executed when the event if detected. <br  />
 <b>Range:</b> The function accepts no arguments and returns no value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>XMC_SCU_STATUS_t Status of configuring the event handler function for the selected event.<br  />
 <b>Range:</b> <em>XMC_SCU_STATUS_OK</em> if the event handler is successfully configured.<br  />
 <em>XMC_SCU_STATUS_ERROR</em> if the input event is invalid.<br  />
</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Assigns the event handler function to be executed on occurrence of the selected event.<br  />
<br  />
If the input event is valid, the handler function will be assigned to a table to be executed when the interrupt is generated and the event status is set in the event status register. By using this API, polling for a particular event can be avoided. This way the CPU utilization will be optimized. Multiple SCU events can generate a common interrupt. When the interrupt is generated, a common interrupt service routine is executed. It checks for status flags of events which can generate the interrupt. The handler function will be executed if the event flag is set.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gaa55b2098ce803174e7dfd680d0c30728">XMC_SCU_INTERRUPT_TriggerEvent()</a>, <a class="el" href="group___s_c_u.html#gae23dfad3e5e11c78791e5d5a777c44a8">XMC_SCU_INTERUPT_GetEventStatus()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc1__scu_8c_source.html#l00812">812</a> of file <a class="el" href="xmc1__scu_8c_source.html">xmc1_scu.c</a>.</p>

</div>
</div>
<a id="gaa55b2098ce803174e7dfd680d0c30728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa55b2098ce803174e7dfd680d0c30728">&#9670;&nbsp;</a></span>XMC_SCU_INTERRUPT_TriggerEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_INTERRUPT_TriggerEvent </td>
          <td>(</td>
          <td class="paramtype">const XMC_SCU_INTERRUPT_EVENT_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Bit mask of the event to be triggered. <b>Range:</b> Use type XMC_SCU_INTERRUPT_EVENT_t for providing the input value. Multiple events can be combined using the <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Triggers the event as if the hardware raised it.<br  />
<br  />
Event will be triggered by setting the respective bitfield in the SRSET register.<br  />
Note: User should enable the NVIC node that handles the respective event for interrupt generation. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___c_m_s_i_s___core___n_v_i_c_functions.html#ga57b3064413dbc7459d9646020fdd8bef">NVIC_EnableIRQ()</a>, <a class="el" href="group___s_c_u.html#gae23dfad3e5e11c78791e5d5a777c44a8">XMC_SCU_INTERUPT_GetEventStatus()</a>, <a class="el" href="group___s_c_u.html#gabd2e577339ff5af48261d18e0e41dc50">XMC_SCU_INTERRUPT_ClearEventStatus()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc1__scu_8c_source.html#l00360">360</a> of file <a class="el" href="xmc1__scu_8c_source.html">xmc1_scu.c</a>.</p>

</div>
</div>
<a id="gae23dfad3e5e11c78791e5d5a777c44a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae23dfad3e5e11c78791e5d5a777c44a8">&#9670;&nbsp;</a></span>XMC_SCU_INTERUPT_GetEventStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">XMC_SCU_INTERRUPT_EVENT_t XMC_SCU_INTERUPT_GetEventStatus </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Status of the SCU events.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the status of all SCU events.<br  />
<br  />
The status is read from the SRRAW register. To check the status of a particular event, the returned value should be masked with the bit mask of the event. The bitmask of events can be obtained using the type XMC_SCU_INTERRUPT_EVENT_t. Multiple events' status can be checked by combining the bit masks using <em>OR</em> operation. After detecting the event, the event status should be cleared using software to detect the event again. </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#gabd2e577339ff5af48261d18e0e41dc50">XMC_SCU_INTERRUPT_ClearEventStatus()</a>, <a class="el" href="group___s_c_u.html#gaa55b2098ce803174e7dfd680d0c30728">XMC_SCU_INTERRUPT_TriggerEvent()</a>, <a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc1__scu_8c_source.html#l00369">369</a> of file <a class="el" href="xmc1__scu_8c_source.html">xmc1_scu.c</a>.</p>

</div>
</div>
<a id="ga9ba1ce317ce89edfea107893fbd8a0be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ba1ce317ce89edfea107893fbd8a0be">&#9670;&nbsp;</a></span>XMC_SCU_IRQHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void XMC_SCU_IRQHandler </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>sr_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sr_num</td><td>Service request number identifying the SCU interrupt generated.<br  />
 <b>Range:</b> 0 to 2. XMC4x devices have one common SCU interrupt, so the value should be 0.<br  />
 But XMC1x devices support 3 interrupt nodes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>
<dl class="section user"><dt>Description</dt><dd>A common function to execute callback functions for multiple events.<br  />
<br  />
It checks for the status of events which can generate the interrupt with the selected service request. If the event is set, the corresponding callback function will be executed. It also clears the event status bit.<br  />
<b>Note:</b> This is an internal function. It should not be called by the user application.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga4ae03c6bcc3ccade266b46d84f7715e6">XMC_SCU_INTERRUPT_SetEventHandler()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc1__scu_8c_source.html#l00843">843</a> of file <a class="el" href="xmc1__scu_8c_source.html">xmc1_scu.c</a>.</p>

</div>
</div>
<a id="ga6ab54dc1771863dfe14729caee0d3ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ab54dc1771863dfe14729caee0d3ab3">&#9670;&nbsp;</a></span>XMC_SCU_RESET_ClearDeviceResetReason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cmsis__gcc_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void XMC_SCU_RESET_ClearDeviceResetReason </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Clears the reset reason bits in the reset status register. <br  />
<br  />
Clearing of the reset status information in the <em>SCU_RSTSTAT</em> register via register bit <em>RSTCLR.RSCLR</em> is strongly recommended to ensure a clear indication of the cause of next reset.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga9239de911e1602022b1e3e1121e0a126">XMC_SCU_RESET_GetDeviceResetReason()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__scu_8h_source.html#l00406">406</a> of file <a class="el" href="xmc__scu_8h_source.html">xmc_scu.h</a>.</p>

<p class="reference">References <a class="el" href="_x_m_c1100_8h_source.html#l04231">SCU_RESET</a>, and <a class="el" href="_x_m_c1100_8h_source.html#l02605">SCU_RESET_RSTCLR_RSCLR_Msk</a>.</p>

</div>
</div>
<a id="ga9239de911e1602022b1e3e1121e0a126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9239de911e1602022b1e3e1121e0a126">&#9670;&nbsp;</a></span>XMC_SCU_RESET_GetDeviceResetReason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cmsis__gcc_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> uint32_t XMC_SCU_RESET_GetDeviceResetReason </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>uint32_t Status representing the reason for device reset.</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Provides the value representing the reason for device reset.<br  />
<br  />
The return value is an encoded word, which can indicate multiple reasons for the last reset. Each bit position of the returned word is representative of a last reset cause. The returned value should be appropriately masked to check the cause of reset. The cause of the last reset gets automatically stored in the <em>SCU_RSTSTAT</em> register. The reset status shall be reset after each startup in order to ensure consistent source indication after the next reset. <b>Range:</b> The type XMC_SCU_RESET_REASON_t can be used to get the bit masks of the reset cause.</dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd><a class="el" href="group___s_c_u.html#ga6ab54dc1771863dfe14729caee0d3ab3">XMC_SCU_RESET_ClearDeviceResetReason()</a> <br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__scu_8h_source.html#l00391">391</a> of file <a class="el" href="xmc__scu_8h_source.html">xmc_scu.h</a>.</p>

<p class="reference">References <a class="el" href="_x_m_c1100_8h_source.html#l04231">SCU_RESET</a>, and <a class="el" href="_x_m_c1100_8h_source.html#l02595">SCU_RESET_RSTSTAT_RSTSTAT_Msk</a>.</p>

</div>
</div>
<a id="ga3b2b4eb2b1fb84d9aa0b3b2997941d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b2b4eb2b1fb84d9aa0b3b2997941d10">&#9670;&nbsp;</a></span>XMC_SCU_SetCcuTriggerHigh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cmsis__gcc_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void XMC_SCU_SetCcuTriggerHigh </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>trigger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>CCU slices to be triggered synchronously via software. The value is a bitmask of CCU slice bits in the register CCUCON. <br  />
 <b>Range:</b> Use type XMC_SCU_CCU_TRIGGER_t for bitmask of individual CCU slices. Multiple slices can be combined using <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Generates active edge(low to high) trigger for multiple CCU units at the same time.<br  />
<br  />
Before executing this API, all the required CCU timers should configure external start. The edge of the start signal should be selected as active edge. The input signal for the CCU slice should be selected as SCU input. The above mentioned configurations can be made using the CCU LLD API XMC_CCU4_SLICE_StartConfig(). CCU timer slice should be started using XMC_CCU4_SLICE_StartTimer() before triggering the timer using this API.<br  />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>XMC_CCU4_SLICE_StartConfig(), XMC_CCU4_SLICE_SetInput(), <a class="el" href="group___s_c_u.html#gaee8a9cc1bea24cd3a6027ecfa02cac9d">XMC_SCU_SetCcuTriggerLow()</a><br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__scu_8h_source.html#l00230">230</a> of file <a class="el" href="xmc__scu_8h_source.html">xmc_scu.h</a>.</p>

<p class="reference">References <a class="el" href="_x_m_c1100_8h_source.html#l04227">SCU_GENERAL</a>.</p>

</div>
</div>
<a id="gaee8a9cc1bea24cd3a6027ecfa02cac9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee8a9cc1bea24cd3a6027ecfa02cac9d">&#9670;&nbsp;</a></span>XMC_SCU_SetCcuTriggerLow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cmsis__gcc_8h.html#aba87361bfad2ae52cfe2f40c1a1dbf9c">__STATIC_INLINE</a> void XMC_SCU_SetCcuTriggerLow </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>trigger</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trigger</td><td>CCU slices to be triggered synchronously via software. The value is a bitmask of CCU slice bits in the register CCUCON. <br  />
 <b>Range:</b> Use type XMC_SCU_CCU_TRIGGER_t for bitmask of individual CCU slices. Multiple slices can be combined using <em>OR</em> operation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None</dd></dl>
<dl class="section user"><dt>Description</dt><dd>Generates passive edge(high to low) trigger for multiple CCU units at the same time.<br  />
<br  />
Before executing this API, all the required CCU timers should configure external start. The edge of the start signal should be selected as passive edge. The input signal for the CCU slice should be selected as SCU input. The above mentioned configurations can be made using the CCU LLD API XMC_CCU4_SLICE_StartConfig(). CCU timer slice should be started using XMC_CCU4_SLICE_StartTimer() before triggering the timer using this API.<br  />
 </dd></dl>
<dl class="section user"><dt>Related APIs:</dt><dd>XMC_CCU4_SLICE_StartConfig(), XMC_CCU4_SLICE_SetInput(), <a class="el" href="group___s_c_u.html#ga3b2b4eb2b1fb84d9aa0b3b2997941d10">XMC_SCU_SetCcuTriggerHigh()</a><br  />
<br  />
<br  />
</dd></dl>

<p class="definition">Definition at line <a class="el" href="xmc__scu_8h_source.html#l00255">255</a> of file <a class="el" href="xmc__scu_8h_source.html">xmc_scu.h</a>.</p>

<p class="reference">References <a class="el" href="_x_m_c1100_8h_source.html#l04227">SCU_GENERAL</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
